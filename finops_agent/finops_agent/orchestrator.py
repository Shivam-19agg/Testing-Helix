from typing import TypedDict, List, Dict, Any
from langgraph.graph import StateGraph, END

# --- State Definition ---
class AgentState(TypedDict):
    """
    Represents the state of our FinOps agent's workflow.
    """
    resources: List[str]  # List of Azure resource IDs to be analyzed.
    recommendations: List[Dict[str, Any]]  # List of recommendations generated by analysis nodes.
    git_log_dir: str  # Path to the local directory for the Git audit log.

# --- Node Imports ---
# Use a relative import to refer to a module within the same package.
from .nodes.analysis.tier_rightsizing import tier_rightsizing_analysis_node


# --- Core Workflow Functions ---

def discovery_node(state: AgentState) -> AgentState:
    """
    Simulates the discovery of resources in an Azure subscription.
    """
    print("---NODE: DISCOVERY---")
    print("Finding resources to analyze...")
    # In a real implementation, this would use the Azure SDK to scan a subscription.
    discovered_resources = [
        "/subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/resourceGroups/rg-prod-1/providers/Microsoft.ApiManagement/service/apim-prod-eus",
        "/subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/resourceGroups/rg-dev-1/providers/Microsoft.ApiManagement/service/apim-dev-wus"
    ]
    state["resources"] = discovered_resources
    print(f"Found {len(discovered_resources)} resources.")
    # The initial state should define the 'recommendations' list,
    # but this ensures it exists for robustness.
    if "recommendations" not in state:
        state["recommendations"] = []
    return state

def finalize_node(state: AgentState) -> AgentState:
    """
    Simulates the final aggregation and review step.
    """
    print("---NODE: FINALIZE---")
    print("Aggregating and finalizing all recommendations...")
    print(f"Total recommendations generated: {len(state['recommendations'])}")
    # In a real implementation, this might filter recommendations or set a final status.
    return state

# --- Graph Definition ---

def build_graph():
    """
    Builds the LangGraph orchestrator.
    """
    workflow = StateGraph(AgentState)

    # Add nodes to the graph
    workflow.add_node("discover", discovery_node)
    workflow.add_node("tier_rightsizing_analysis", tier_rightsizing_analysis_node)
    # TODO: Add other analysis nodes here and run them in parallel.
    workflow.add_node("finalize", finalize_node)

    # Define the workflow edges
    workflow.set_entry_point("discover")
    workflow.add_edge("discover", "tier_rightsizing_analysis")
    workflow.add_edge("tier_rightsizing_analysis", "finalize")
    workflow.add_edge("finalize", END)

    return workflow.compile()

# --- Main Execution Block ---

if __name__ == "__main__":
    # This allows running the orchestrator directly for testing.
    app = build_graph()

    # Define the initial state for the workflow.
    initial_state = {
        "resources": [],
        "recommendations": [],
        "git_log_dir": "/tmp/finops_git_audit_log"
    }

    print("---STARTING FINOPS ANALYSIS WORKFLOW---")
    final_state = app.invoke(initial_state)
    print("---FINOPS ANALYSIS WORKFLOW COMPLETE---")

    print("\n---FINAL STATE---")
    import json
    print(json.dumps(final_state, indent=2))
